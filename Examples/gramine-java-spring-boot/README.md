# Spring-Boot java as GSC
## Disclaimer
* This generated confidential computing image is for non-production usage.

* Tested on:</br>
  - Type: Azure Confidential Computing(Virtual Machine)</br>
  - OS: Linux(ubuntu 20.04)</br>
  - Size: Standard DC1s v3(1vcpu, 8 GiB memory )</br>
  - OpenJDK11

## Software requirements
1. Follow https://github.com/gramineproject/gsc to find a reference to the documentation to install Gramine and GSC, which are necessary to run this example 

2. It is necessary to install the openjdk-11 package on your machine so that gradlew can consume the files. Use the command below to install it 
```sh
$ sudo apt-get install openjdk-11-jdk
```

## Build and run graminized Docker image
1.  Enter the directory with gramine-simple java:
```sh
$ cd gsc/Examples/gramine-java-spring-boot/
```
2. Grant permissions:
```sh
$ sudo chmod 755 spring-boot-web-service/gradlew
```
3. Building a project using Gradle:
```sh
$ (cd spring-boot-web-service/; ./gradlew build)
```
4. Build a Docker image. Dockerfile copies the project jar file that was generated by Gradle to build the image:
```sh
$ docker build -t gramine-java-spring-boot .
```
5. Cleaning up files that will be no longer used:
```sh
$ (cd spring-boot-web-service/; ./gradlew clean)
```
6.  Go back under the gsc/... directory:
```sh
$ cd ../..
``` 
7. If you don't already have a signing key, then generate one using the following command presented below. If you have generated the key according to the instructions described in https://gramine.readthedocs.io/en/stable/quickstart.html then you don't need to execute this command instead, you need to indicate the correct path to it when signing the image:
```sh
$ openssl genrsa -3 -out enclave-key.pem 3072
```
8.  Graminize the Docker image using gsc build (this step can take some time!):
```sh 
$ ./gsc build gramine-java-spring-boot Examples/gramine-java-spring-boot/gramine-java-spring-boot.manifest -c Examples/gramine-java-spring-boot/config.yaml
```
9. Sign the graminized Docker image using gsc sign-image:
```sh
$ ./gsc sign-image gramine-java-spring-boot  enclave-key.pem -c Examples/gramine-java-spring-boot/config.yaml
```
10. Run graminized image. The first parameter is responsible for adding a host device to the container, and this is the driver for SGX. The second parameter is used to bind mount a volume in the form of an ASEM service, which provides key provisioning and remote attestation. The third parameter is the port on which the application will run:

*  To run the image on the default port set to 8080, run the command (the application may take a while to load):
```sh
$ docker run --rm --device=/dev/sgx_enclave -v /var/run/aesmd/aesm.socket:/var/run/aesmd/aesm.socket -p 8080:8080 -d gsc-gramine-java-spring-boot  
```
* To run the image on a customized port using an environment variable, i.e. 9080, run the following command (the application may take a while to load):
```sh
$ docker run --rm --device=/dev/sgx_enclave -v /var/run/aesmd/aesm.socket:/var/run/aesmd/aesm.socket -e SERVER_PORT=9080 -p 9080:9080 -d gsc-gramine-java-spring-boot
```
## Result 
1. Once you have the graminized container up and running, verify its correctness by calling the following command below. The result should be the following text - "Hello from Graminized Spring Boot application".
```sh
$ wget -q localhost:<port> 
$ cat index.html
```

2. To terminate the graminized container with Spring-Boot application, run the command:
```sh
$ docker stop <containerID>
```